\hypertarget{group__transforming__operators}{}\doxysection{Transforming Operators}
\label{group__transforming__operators}\index{Transforming Operators@{Transforming Operators}}


Transforming operators are operators that transform items provided by observable.  


\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$flat\+\_\+map\+\_\+callable$<$ Type $>$ Callable$>$ }\\auto \mbox{\hyperlink{group__transforming__operators_gae4d30f7ae23a7d62aa761f26abf18008}{rpp\+::details\+::member\+\_\+overload$<$ Type, Specific\+Observable, flat\+\_\+map\+\_\+tag $>$\+::flat\+\_\+map}} (Callable \&\&callable) const \&requires is\+\_\+header\+\_\+included$<$ flat\+\_\+map\+\_\+tag
\begin{DoxyCompactList}\small\item\em Transform emissions to observables via provided function and then merge emissions from such an observables. \end{DoxyCompactList}\item 
{\footnotesize template$<$std\+::invocable$<$ Type $>$ Key\+Selector, std\+::invocable$<$ Type $>$ Value\+Selector = std\+::identity, typename T\+Key  = rpp\+::utils\+::decayed\+\_\+invoke\+\_\+result\+\_\+t$<$\+Key\+Selector, Type$>$, std\+::relation$<$ T\+Key, T\+Key $>$ Key\+Comparator = std\+::less$<$\+T\+Key$>$$>$ }\\auto \mbox{\hyperlink{group__transforming__operators_gaf3399da92ac6a0a4c392107b5b405a60}{rpp\+::details\+::member\+\_\+overload$<$ Type, Specific\+Observable, group\+\_\+by\+\_\+tag $>$\+::group\+\_\+by}} (Key\+Selector \&\&key\+\_\+selector, Value\+Selector \&\&value\+\_\+selector=\{\}, Key\+Comparator \&\&comparator=\{\}) const \&requires is\+\_\+header\+\_\+included$<$ group\+\_\+by\+\_\+tag
\begin{DoxyCompactList}\small\item\em Divide original observable into multiple observables where each new observable emits some group of values from original observable. \end{DoxyCompactList}\item 
{\footnotesize template$<$std\+::invocable$<$ Type $>$ Callable$>$ }\\auto \mbox{\hyperlink{group__transforming__operators_ga2215c20ce73e16977568e7db1900ce65}{rpp\+::details\+::member\+\_\+overload$<$ Type, Specific\+Observable, map\+\_\+tag $>$\+::map}} (Callable \&\&callable) const \&requires is\+\_\+header\+\_\+included$<$ map\+\_\+tag
\begin{DoxyCompactList}\small\item\em Transform the items emitted by an Observable via applying a function to each item and emitting result. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Result , scan\+\_\+accumulator$<$ Result, Type $>$ Accumulator\+Fn$>$ }\\auto \mbox{\hyperlink{group__transforming__operators_gad4cf46a565f1081cd7b8bc26aa99e640}{rpp\+::details\+::member\+\_\+overload$<$ Type, Specific\+Observable, scan\+\_\+tag $>$\+::scan}} (Result \&\&initial\+\_\+value, Accumulator\+Fn \&\&accumulator) const \&requires is\+\_\+header\+\_\+included$<$ scan\+\_\+tag
\begin{DoxyCompactList}\small\item\em Apply accumulator function for each emission from observable and result of accumulator from previous step and emit (and cache) resulting value. \end{DoxyCompactList}\item 
{\footnotesize template$<$switch\+\_\+map\+\_\+callable$<$ Type $>$ Callable$>$ }\\auto \mbox{\hyperlink{group__transforming__operators_ga70e93b5ebd0da19d8acdf2af6497cb88}{rpp\+::details\+::member\+\_\+overload$<$ Type, Specific\+Observable, switch\+\_\+map\+\_\+tag $>$\+::switch\+\_\+map}} (Callable \&\&callable) const \&requires is\+\_\+header\+\_\+included$<$ switch\+\_\+map\+\_\+tag
\begin{DoxyCompactList}\small\item\em convert an Observable that emits Observables into a single Observable that emits the items emitted by the most-\/recently-\/emitted of those Observables \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Transforming operators are operators that transform items provided by observable. 

\begin{DoxySeeAlso}{See also}
\href{https://reactivex.io/documentation/operators.html\#transforming}{\texttt{ https\+://reactivex.\+io/documentation/operators.\+html\#transforming}} 
\end{DoxySeeAlso}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{group__transforming__operators_gae4d30f7ae23a7d62aa761f26abf18008}\label{group__transforming__operators_gae4d30f7ae23a7d62aa761f26abf18008}} 
\index{Transforming Operators@{Transforming Operators}!flat\_map@{flat\_map}}
\index{flat\_map@{flat\_map}!Transforming Operators@{Transforming Operators}}
\doxysubsubsection{\texorpdfstring{flat\_map()}{flat\_map()}}
{\footnotesize\ttfamily template$<$constraint\+::decayed\+\_\+type Type, typename Specific\+Observable $>$ \\
template$<$flat\+\_\+map\+\_\+callable$<$ Type $>$ Callable$>$ \\
auto \mbox{\hyperlink{structrpp_1_1details_1_1member__overload}{rpp\+::details\+::member\+\_\+overload}}$<$ Type, Specific\+Observable, flat\+\_\+map\+\_\+tag $>$\+::flat\+\_\+map (\begin{DoxyParamCaption}\item[{Callable \&\&}]{callable }\end{DoxyParamCaption}) const \&}



Transform emissions to observables via provided function and then merge emissions from such an observables. 

\begin{DoxyWarning}{Warning}
According to observable contract (\href{https://reactivex.io/documentation/contract.html}{\texttt{ https\+://reactivex.\+io/documentation/contract.\+html}}) emissions from any observable should be serialized, so, resulting observable uses mutex to satisfy this requirement
\end{DoxyWarning}


Actually it makes {\ttfamily map} and then {\ttfamily merge}.


\begin{DoxyParams}{Parameters}
{\em callable} & Function to transform item to observable \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
new \mbox{\hyperlink{classrpp_1_1specific__observable}{specific\+\_\+observable}} with the flat\+\_\+map operator as most recent operator. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
\#include $<$\mbox{\hyperlink{flat__map_8hpp_source}{rpp/operators/flat\+\_\+map.\+hpp}}$>$
\end{DoxyWarning}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{    \mbox{\hyperlink{group__creational__operators_gabc5067fa9aefaa803f6e329b75faa00c}{rpp::source::just}}(1, 2, 3)}
\DoxyCodeLine{            .flat\_map([](\textcolor{keywordtype}{int} val) \{ \textcolor{keywordflow}{return} rpp::source::from\_iterable(std::vector(val, val)); \})}
\DoxyCodeLine{            .subscribe([](\textcolor{keywordtype}{int} v) \{ std::cout << v << \textcolor{stringliteral}{" "}; \});}
\DoxyCodeLine{    \textcolor{comment}{// Output: 1 2 2 3 3 3}}
\end{DoxyCodeInclude}

\end{DoxyParagraph}
\begin{DoxySeeAlso}{See also}
\href{https://reactivex.io/documentation/operators/flatmap.html}{\texttt{ https\+://reactivex.\+io/documentation/operators/flatmap.\+html}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__transforming__operators_gaf3399da92ac6a0a4c392107b5b405a60}\label{group__transforming__operators_gaf3399da92ac6a0a4c392107b5b405a60}} 
\index{Transforming Operators@{Transforming Operators}!group\_by@{group\_by}}
\index{group\_by@{group\_by}!Transforming Operators@{Transforming Operators}}
\doxysubsubsection{\texorpdfstring{group\_by()}{group\_by()}}
{\footnotesize\ttfamily template$<$constraint\+::decayed\+\_\+type Type, typename Specific\+Observable $>$ \\
template$<$std\+::invocable$<$ Type $>$ Key\+Selector, std\+::invocable$<$ Type $>$ Value\+Selector = std\+::identity, typename T\+Key  = rpp\+::utils\+::decayed\+\_\+invoke\+\_\+result\+\_\+t$<$\+Key\+Selector, Type$>$, std\+::relation$<$ T\+Key, T\+Key $>$ Key\+Comparator = std\+::less$<$\+T\+Key$>$$>$ \\
auto \mbox{\hyperlink{structrpp_1_1details_1_1member__overload}{rpp\+::details\+::member\+\_\+overload}}$<$ Type, Specific\+Observable, group\+\_\+by\+\_\+tag $>$\+::group\+\_\+by (\begin{DoxyParamCaption}\item[{Key\+Selector \&\&}]{key\+\_\+selector,  }\item[{Value\+Selector \&\&}]{value\+\_\+selector = {\ttfamily \{\}},  }\item[{Key\+Comparator \&\&}]{comparator = {\ttfamily \{\}} }\end{DoxyParamCaption}) const \&}



Divide original observable into multiple observables where each new observable emits some group of values from original observable. 



Original observable applies {\ttfamily key\+\_\+selector} to obtain key and split values to sub-\/groups based on these keys and then send \mbox{\hyperlink{classrpp_1_1grouped__observable}{rpp\+::grouped\+\_\+observable}} with this key. Such an grouped observables emit values which has same value of key.


\begin{DoxyParams}{Parameters}
{\em key\+\_\+selector} & Function which determines key for provided item \\
\hline
{\em value\+\_\+selector} & Function which determines value to be emitted to grouped observable \\
\hline
{\em comparator} & Function to provide relation between key types\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
new \mbox{\hyperlink{classrpp_1_1specific__observable}{specific\+\_\+observable}} with the group\+\_\+by operator as most recent operator. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
\#include $<$\mbox{\hyperlink{group__by_8hpp_source}{rpp/operators/group\+\_\+by.\+hpp}}$>$
\end{DoxyWarning}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{    \mbox{\hyperlink{group__creational__operators_gabc5067fa9aefaa803f6e329b75faa00c}{rpp::source::just}}(1, 2, 3, 4, 5, 6, 7, 8)}
\DoxyCodeLine{            .group\_by([](\textcolor{keywordtype}{int}   v) \{ \textcolor{keywordflow}{return} v \% 2 == 0; \})}
\DoxyCodeLine{            .subscribe([](\textcolor{keyword}{auto} grouped\_observable)}
\DoxyCodeLine{            \{}
\DoxyCodeLine{                \textcolor{keyword}{auto} key = grouped\_observable.get\_key();}
\DoxyCodeLine{                std::cout << \textcolor{stringliteral}{"new grouped observable "} << key << std::endl;}
\DoxyCodeLine{                grouped\_observable.subscribe([key](\textcolor{keywordtype}{int} val)}
\DoxyCodeLine{                \{}
\DoxyCodeLine{                    std::cout << \textcolor{stringliteral}{"key ["} << key << \textcolor{stringliteral}{"] Val: "} << val << std::endl;}
\DoxyCodeLine{                \});}
\DoxyCodeLine{            \});}
\DoxyCodeLine{    \textcolor{comment}{// Output: new grouped observable 0}}
\DoxyCodeLine{    \textcolor{comment}{//         key [0] Val: 1}}
\DoxyCodeLine{    \textcolor{comment}{//         new grouped observable 1}}
\DoxyCodeLine{    \textcolor{comment}{//         key [1] Val: 2}}
\DoxyCodeLine{    \textcolor{comment}{//         key [0] Val: 3}}
\DoxyCodeLine{    \textcolor{comment}{//         key [1] Val: 4}}
\DoxyCodeLine{    \textcolor{comment}{//         key [0] Val: 5}}
\DoxyCodeLine{    \textcolor{comment}{//         key [1] Val: 6}}
\DoxyCodeLine{    \textcolor{comment}{//         key [0] Val: 7}}
\DoxyCodeLine{    \textcolor{comment}{//         key [1] Val: 8}}
\end{DoxyCodeInclude}
 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{    \textcolor{keyword}{struct }Person}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        std::string name;}
\DoxyCodeLine{        \textcolor{keywordtype}{int} age;}
\DoxyCodeLine{    \};}
\DoxyCodeLine{    \mbox{\hyperlink{group__creational__operators_gabc5067fa9aefaa803f6e329b75faa00c}{rpp::source::just}}(Person\{\textcolor{stringliteral}{"Kate"}, 18\},}
\DoxyCodeLine{                      Person\{\textcolor{stringliteral}{"Alex"}, 25\},}
\DoxyCodeLine{                      Person\{\textcolor{stringliteral}{"Nick"}, 18\},}
\DoxyCodeLine{                      Person\{\textcolor{stringliteral}{"Jack"}, 25\},}
\DoxyCodeLine{                      Person\{\textcolor{stringliteral}{"Tom"}, 30\},}
\DoxyCodeLine{                      Person\{\textcolor{stringliteral}{"Vanda"}, 18\})}
\DoxyCodeLine{            .\mbox{\hyperlink{group__transforming__operators_gaf3399da92ac6a0a4c392107b5b405a60}{group\_by}}([](\textcolor{keyword}{const} Person\& v) \{ \textcolor{keywordflow}{return} v.age; \}, [](\textcolor{keyword}{const} Person\& v) \{ \textcolor{keywordflow}{return} v.name; \})}
\DoxyCodeLine{            .subscribe([](\textcolor{keyword}{auto} grouped\_observable)}
\DoxyCodeLine{            \{}
\DoxyCodeLine{                grouped\_observable.subscribe([age = grouped\_observable.get\_key()](\textcolor{keyword}{const} std::string\& name)}
\DoxyCodeLine{                \{}
\DoxyCodeLine{                    std::cout << \textcolor{stringliteral}{"Age ["} << age << \textcolor{stringliteral}{"] Name: "} << name << std::endl;}
\DoxyCodeLine{                \});}
\DoxyCodeLine{            \});}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Output: Age [18] Name: Kate}}
\DoxyCodeLine{    \textcolor{comment}{//         Age [25] Name: Alex}}
\DoxyCodeLine{    \textcolor{comment}{//         Age [18] Name: Nick}}
\DoxyCodeLine{    \textcolor{comment}{//         Age [25] Name: Jack}}
\DoxyCodeLine{    \textcolor{comment}{//         Age [30] Name: Tom}}
\DoxyCodeLine{    \textcolor{comment}{//         Age [18] Name: Vanda}}
\end{DoxyCodeInclude}

\end{DoxyParagraph}
\begin{DoxySeeAlso}{See also}
\href{https://reactivex.io/documentation/operators/groupby.html}{\texttt{ https\+://reactivex.\+io/documentation/operators/groupby.\+html}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__transforming__operators_ga2215c20ce73e16977568e7db1900ce65}\label{group__transforming__operators_ga2215c20ce73e16977568e7db1900ce65}} 
\index{Transforming Operators@{Transforming Operators}!map@{map}}
\index{map@{map}!Transforming Operators@{Transforming Operators}}
\doxysubsubsection{\texorpdfstring{map()}{map()}}
{\footnotesize\ttfamily template$<$constraint\+::decayed\+\_\+type Type, typename Specific\+Observable $>$ \\
template$<$std\+::invocable$<$ Type $>$ Callable$>$ \\
auto \mbox{\hyperlink{structrpp_1_1details_1_1member__overload}{rpp\+::details\+::member\+\_\+overload}}$<$ Type, Specific\+Observable, map\+\_\+tag $>$\+::map (\begin{DoxyParamCaption}\item[{Callable \&\&}]{callable }\end{DoxyParamCaption}) const \&}



Transform the items emitted by an Observable via applying a function to each item and emitting result. 

\begin{DoxyNote}{Note}
The Map operator can keep same type of value or change it to some another type.
\end{DoxyNote}



\begin{DoxyParams}{Parameters}
{\em callable} & is callable used to provide this transformation. Should accept Type of original observable and return type for new observable \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
new \mbox{\hyperlink{classrpp_1_1specific__observable}{specific\+\_\+observable}} with the Map operator as most recent operator. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
\#include $<$\mbox{\hyperlink{map_8hpp_source}{rpp/operators/map.\+hpp}}$>$
\end{DoxyWarning}
\begin{DoxyParagraph}{Example with same type\+:}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{    \mbox{\hyperlink{group__creational__operators_gabc5067fa9aefaa803f6e329b75faa00c}{rpp::source::just}}(42)}
\DoxyCodeLine{            .map([](\textcolor{keywordtype}{int} value)}
\DoxyCodeLine{            \{}
\DoxyCodeLine{                \textcolor{keywordflow}{return} value + 10;}
\DoxyCodeLine{            \})}
\DoxyCodeLine{            .subscribe([](\textcolor{keywordtype}{int} v) \{ std::cout << v << std::endl; \});}
\DoxyCodeLine{    \textcolor{comment}{// Output: 52}}
\end{DoxyCodeInclude}
 
\end{DoxyParagraph}
\begin{DoxyParagraph}{Example with changed type\+:}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{    \mbox{\hyperlink{group__creational__operators_gabc5067fa9aefaa803f6e329b75faa00c}{rpp::source::just}}(42)}
\DoxyCodeLine{            .map([](\textcolor{keywordtype}{int} value)}
\DoxyCodeLine{            \{}
\DoxyCodeLine{                \textcolor{keywordflow}{return} std::to\_string(value) + \textcolor{stringliteral}{" VAL"};}
\DoxyCodeLine{            \})}
\DoxyCodeLine{            .subscribe([](std::string v) \{ std::cout << v << std::endl; \});}
\DoxyCodeLine{    \textcolor{comment}{// Output: 42 VAL}}
\end{DoxyCodeInclude}
 
\end{DoxyParagraph}
\begin{DoxySeeAlso}{See also}
\href{https://reactivex.io/documentation/operators/map.html}{\texttt{ https\+://reactivex.\+io/documentation/operators/map.\+html}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__transforming__operators_gad4cf46a565f1081cd7b8bc26aa99e640}\label{group__transforming__operators_gad4cf46a565f1081cd7b8bc26aa99e640}} 
\index{Transforming Operators@{Transforming Operators}!scan@{scan}}
\index{scan@{scan}!Transforming Operators@{Transforming Operators}}
\doxysubsubsection{\texorpdfstring{scan()}{scan()}}
{\footnotesize\ttfamily template$<$constraint\+::decayed\+\_\+type Type, typename Specific\+Observable $>$ \\
template$<$typename Result , scan\+\_\+accumulator$<$ Result, Type $>$ Accumulator\+Fn$>$ \\
auto \mbox{\hyperlink{structrpp_1_1details_1_1member__overload}{rpp\+::details\+::member\+\_\+overload}}$<$ Type, Specific\+Observable, scan\+\_\+tag $>$\+::scan (\begin{DoxyParamCaption}\item[{Result \&\&}]{initial\+\_\+value,  }\item[{Accumulator\+Fn \&\&}]{accumulator }\end{DoxyParamCaption}) const \&}



Apply accumulator function for each emission from observable and result of accumulator from previous step and emit (and cache) resulting value. 




\begin{DoxyParams}{Parameters}
{\em initial\+\_\+value} & initial value for seed which will be applied for first value from observable (instead of emitting this as first value). Then it will be replaced with result and etc. \\
\hline
{\em accumulator} & function which accepts seed value and new value from observable and return new value of seed. Can accept seed by move-\/reference.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
new \mbox{\hyperlink{classrpp_1_1specific__observable}{specific\+\_\+observable}} with the scan operator as most recent operator. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
\#include $<$\mbox{\hyperlink{scan_8hpp_source}{rpp/operators/scan.\+hpp}}$>$
\end{DoxyWarning}
\begin{DoxyParagraph}{Example}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{    \mbox{\hyperlink{group__creational__operators_gabc5067fa9aefaa803f6e329b75faa00c}{rpp::source::just}}(1,2,3)}
\DoxyCodeLine{            .scan(0, std::plus<int>\{\})}
\DoxyCodeLine{            .subscribe([](\textcolor{keywordtype}{int} v) \{ std::cout << v << std::endl; \});}
\DoxyCodeLine{    \textcolor{comment}{// Output: 1 3 6}}
\end{DoxyCodeInclude}
 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{    \mbox{\hyperlink{group__creational__operators_gabc5067fa9aefaa803f6e329b75faa00c}{rpp::source::just}}(1,2,3)}
\DoxyCodeLine{            .scan(std::vector<int>\{\}, [](std::vector<int>\&\& seed, \textcolor{keywordtype}{int} new\_value) -\/> std::vector<int>\&\&}
\DoxyCodeLine{            \{}
\DoxyCodeLine{                seed.push\_back(new\_value);}
\DoxyCodeLine{                \textcolor{keywordflow}{return} std::move(seed);}
\DoxyCodeLine{            \})}
\DoxyCodeLine{            .subscribe([](\textcolor{keyword}{const} std::vector<int>\& v)}
\DoxyCodeLine{            \{}
\DoxyCodeLine{                std::cout << \textcolor{stringliteral}{"vector: "};}
\DoxyCodeLine{                \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} val : v)}
\DoxyCodeLine{                    std::cout << val << \textcolor{stringliteral}{" "};}
\DoxyCodeLine{                std::cout << std::endl;}
\DoxyCodeLine{            \});}
\DoxyCodeLine{    \textcolor{comment}{// Output: vector: 1}}
\DoxyCodeLine{    \textcolor{comment}{//         vector: 1 2}}
\DoxyCodeLine{    \textcolor{comment}{//         vector: 1 2 3}}
\end{DoxyCodeInclude}

\end{DoxyParagraph}
\begin{DoxySeeAlso}{See also}
\href{https://reactivex.io/documentation/operators/scan.html}{\texttt{ https\+://reactivex.\+io/documentation/operators/scan.\+html}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__transforming__operators_ga70e93b5ebd0da19d8acdf2af6497cb88}\label{group__transforming__operators_ga70e93b5ebd0da19d8acdf2af6497cb88}} 
\index{Transforming Operators@{Transforming Operators}!switch\_map@{switch\_map}}
\index{switch\_map@{switch\_map}!Transforming Operators@{Transforming Operators}}
\doxysubsubsection{\texorpdfstring{switch\_map()}{switch\_map()}}
{\footnotesize\ttfamily template$<$constraint\+::decayed\+\_\+type Type, typename Specific\+Observable $>$ \\
template$<$switch\+\_\+map\+\_\+callable$<$ Type $>$ Callable$>$ \\
auto \mbox{\hyperlink{structrpp_1_1details_1_1member__overload}{rpp\+::details\+::member\+\_\+overload}}$<$ Type, Specific\+Observable, switch\+\_\+map\+\_\+tag $>$\+::switch\+\_\+map (\begin{DoxyParamCaption}\item[{Callable \&\&}]{callable }\end{DoxyParamCaption}) const \&}



convert an Observable that emits Observables into a single Observable that emits the items emitted by the most-\/recently-\/emitted of those Observables 



Actually it makes {\ttfamily map} and then {\ttfamily switch\+\_\+on\+\_\+next}.


\begin{DoxyParams}{Parameters}
{\em callable} & Function to transform item to observable \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
new \mbox{\hyperlink{classrpp_1_1specific__observable}{specific\+\_\+observable}} with the switch\+\_\+map operator as most recent operator. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
\#include $<$\mbox{\hyperlink{switch__map_8hpp_source}{rpp/operators/switch\+\_\+map.\+hpp}}$>$
\end{DoxyWarning}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{    \mbox{\hyperlink{group__creational__operators_gabc5067fa9aefaa803f6e329b75faa00c}{rpp::source::just}}(1, 2, 3)}
\DoxyCodeLine{            .switch\_map([](\textcolor{keywordtype}{int} val) \{}
\DoxyCodeLine{                \textcolor{keywordflow}{if} (val == 1)}
\DoxyCodeLine{                    \textcolor{keywordflow}{return} rpp::source::never<int>()}
\DoxyCodeLine{                        .lift([\&](\mbox{\hyperlink{classrpp_1_1dynamic__subscriber}{rpp::dynamic\_subscriber<int>}} sub) \{}
\DoxyCodeLine{                            sub.get\_subscription().add([\&]() \{}
\DoxyCodeLine{                                std::cout << \textcolor{stringliteral}{"x-\/"}; \textcolor{comment}{// x is notation for unsubscribed}}
\DoxyCodeLine{                            \});}
\DoxyCodeLine{                            \textcolor{keywordflow}{return} sub;}
\DoxyCodeLine{                        \})}
\DoxyCodeLine{                        .as\_dynamic();}
\DoxyCodeLine{}
\DoxyCodeLine{                \textcolor{keywordflow}{return} rpp::source::from\_iterable(std::vector\{val, val\})}
\DoxyCodeLine{                    .as\_dynamic();}
\DoxyCodeLine{            \})}
\DoxyCodeLine{            .subscribe([](\textcolor{keywordtype}{int} v) \{ std::cout << v << \textcolor{stringliteral}{"-\/"}; \});}
\DoxyCodeLine{    \textcolor{comment}{// Output: x-\/2-\/2-\/3-\/3-\/}}
\end{DoxyCodeInclude}

\end{DoxyParagraph}
\begin{DoxySeeAlso}{See also}
\href{https://reactivex.io/documentation/operators/switchmap.html}{\texttt{ https\+://reactivex.\+io/documentation/operators/switchmap.\+html}} 
\end{DoxySeeAlso}
